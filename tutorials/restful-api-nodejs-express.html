<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building RESTful APIs with Node.js and Express - Tutorial | Klaus Mutwiri</title>
    <meta name="description" content="Learn how to build scalable REST APIs from scratch using Node.js, Express, authentication, validation, and modern best practices.">
    <meta name="keywords" content="Node.js, Express, REST API, JWT, authentication, PostgreSQL, tutorial, step-by-step">
    <meta name="author" content="Klaus Mutwiri">
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Building RESTful APIs with Node.js and Express - Tutorial">
    <meta property="og:description" content="Learn how to build scalable REST APIs from scratch using Node.js, Express, authentication, validation, and modern best practices.">
    <meta property="og:image" content="https://klaus-portifoliowebsite.netlify.app/img/tutorial-rest-api.jpg">
    <meta property="og:url" content="https://klaus-portifoliowebsite.netlify.app/tutorials/restful-api-nodejs-express.html">
    <meta property="og:type" content="article">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Building RESTful APIs with Node.js and Express - Tutorial">
    <meta name="twitter:description" content="Learn how to build scalable REST APIs from scratch using Node.js, Express, authentication, validation, and modern best practices.">
    <meta name="twitter:image" content="https://klaus-portifoliowebsite.netlify.app/img/tutorial-rest-api.jpg">
    
    <!-- Canonical Link -->
    <link rel="canonical" href="https://klaus-portifoliowebsite.netlify.app/tutorials/restful-api-nodejs-express.html">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="32x32" href="../img/favicon-optimized.png">
    <link rel="apple-touch-icon" sizes="180x180" href="../img/favicon-optimized.png">
    
    <!-- Stylesheet -->
    <link rel="stylesheet" href="../styles.css">
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
</head>
<body class="tutorial-page">
    <!-- Navigation -->
    <nav class="navbar" role="navigation">
        <div class="nav-container">
            <div class="nav-logo">Portfolio</div>
            <ul class="nav-menu">
                <li><a href="../index.html">Home</a></li>
                <li><a href="../tutorials.html">Tutorials</a></li>
                <li><a href="../blog.html">Blog</a></li>
                <li><a href="../index.html#contact">Contact</a></li>
            </ul>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="tutorial-container">
        <div class="tutorial-header">
            <div class="tutorial-meta">
                <span class="tutorial-category">Backend Development</span>
                <span class="tutorial-difficulty">Intermediate</span>
                <span class="tutorial-duration">45 min</span>
            </div>
            <h1>Building RESTful APIs with Node.js and Express</h1>
            <p class="tutorial-subtitle">Learn how to build scalable REST APIs from scratch using Node.js, Express, authentication, validation, and modern best practices.</p>
        </div>

        <div class="tutorial-content">
            <!-- Prerequisites -->
            <section class="tutorial-section">
                <h2>Prerequisites</h2>
                <p>Before starting this tutorial, you should have:</p>
                <ul>
                    <li>Basic understanding of JavaScript and Node.js</li>
                    <li>Familiarity with HTTP methods and REST concepts</li>
                    <li>Node.js and npm installed on your machine</li>
                    <li>PostgreSQL installed (or access to a cloud database)</li>
                </ul>
            </section>

            <!-- Setup -->
            <section class="tutorial-section">
                <h2>Step 1: Project Setup</h2>
                <p>Let's start by creating a new Node.js project and installing the necessary dependencies:</p>
                
                <h3>Initialize Project</h3>
                <pre><code class="language-bash"># Create project directory
mkdir restful-api-tutorial
cd restful-api-tutorial

# Initialize npm project
npm init -y

# Install dependencies
npm install express cors helmet morgan dotenv
npm install pg bcryptjs jsonwebtoken
npm install joi express-rate-limit

# Install dev dependencies
npm install -D nodemon jest supertest</code></pre>

                <h3>Package.json Scripts</h3>
                <pre><code class="language-json">{
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest",
    "test:watch": "jest --watch"
  }
}</code></pre>

                <h3>Environment Variables</h3>
                <p>Create a `.env` file for configuration:</p>
                <pre><code class="language-bash"># Server Configuration
PORT=3000
NODE_ENV=development

# Database Configuration
DB_HOST=localhost
DB_PORT=5432
DB_NAME=restful_api
DB_USER=your_username
DB_PASSWORD=your_password

# JWT Configuration
JWT_SECRET=your_super_secret_jwt_key_here
JWT_EXPIRES_IN=7d</code></pre>
            </section>

            <!-- Database Setup -->
            <section class="tutorial-section">
                <h2>Step 2: Database Setup</h2>
                <p>Let's create our database schema. We'll build a simple blog API with users and posts:</p>
                
                <h3>Create Database Table</h3>
                <pre><code class="language-sql">-- Create users table
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create posts table
CREATE TABLE posts (
    id SERIAL PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    author_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    published BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create indexes for better performance
CREATE INDEX idx_posts_author_id ON posts(author_id);
CREATE INDEX idx_posts_published ON posts(published);
CREATE INDEX idx_users_email ON users(email);</code></pre>

                <h3>Database Connection Setup</h3>
                <pre><code class="language-javascript">// config/database.js
const { Pool } = require('pg');

const pool = new Pool({
  host: process.env.DB_HOST,
  port: process.env.DB_PORT,
  database: process.env.DB_NAME,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
});

module.exports = {
  query: (text, params) => pool.query(text, params),
};</code></pre>
            </section>

            <!-- Express Server Setup -->
            <section class="tutorial-section">
                <h2>Step 3: Express Server Setup</h2>
                <p>Now let's create our Express server with proper middleware configuration:</p>
                
                <h3>Server Configuration</h3>
                <pre><code class="language-javascript">// server.js
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const rateLimit = require('express-rate-limit');

const authRoutes = require('./routes/auth');
const userRoutes = require('./routes/users');
const postRoutes = require('./routes/posts');

const app = express();

// Security middleware
app.use(helmet());
app.use(cors({
  origin: process.env.NODE_ENV === 'production' 
    ? 'https://yourdomain.com' 
    : 'http://localhost:3000',
  credentials: true,
}));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again later.',
});
app.use('/api/', limiter);

// Logging
app.use(morgan('combined'));

// Body parsing middleware
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/posts', postRoutes);

// Health check endpoint
app.get('/api/health', (req, res) => {
  res.status(200).json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  });
});

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({ error: 'Route not found' });
});

// Global error handler
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ 
    error: process.env.NODE_ENV === 'production' 
      ? 'Internal server error' 
      : err.message 
  });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});</code></pre>
            </section>

            <!-- Authentication -->
            <section class="tutorial-section">
                <h2>Step 4: Authentication System</h2>
                <p>Let's implement JWT-based authentication with secure password hashing:</p>
                
                <h3>JWT Utilities</h3>
                <pre><code class="language-javascript">// utils/jwt.js
const jwt = require('jsonwebtoken');

const generateToken = (payload) => {
  return jwt.sign(payload, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRES_IN,
  });
};

const verifyToken = (token) => {
  return jwt.verify(token, process.env.JWT_SECRET);
};

module.exports = { generateToken, verifyToken };</code></pre>

                <h3>Password Hashing</h3>
                <pre><code class="language-javascript">// utils/password.js
const bcrypt = require('bcryptjs');

const hashPassword = async (password) => {
  const saltRounds = 12;
  return await bcrypt.hash(password, saltRounds);
};

const comparePassword = async (password, hash) => {
  return await bcrypt.compare(password, hash);
};

module.exports = { hashPassword, comparePassword };</code></pre>

                <h3>Authentication Middleware</h3>
                <pre><code class="language-javascript">// middleware/auth.js
const { verifyToken } = require('../utils/jwt');

const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN

  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }

  try {
    const decoded = verifyToken(token);
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(403).json({ error: 'Invalid or expired token' });
  }
};

module.exports = { authenticateToken };</code></pre>

                <h3>Authentication Routes</h3>
                <pre><code class="language-javascript">// routes/auth.js
const express = require('express');
const Joi = require('joi');
const db = require('../config/database');
const { hashPassword, comparePassword } = require('../utils/password');
const { generateToken } = require('../utils/jwt');

const router = express.Router();

// Validation schemas
const registerSchema = Joi.object({
  username: Joi.string().min(3).max(50).required(),
  email: Joi.string().email().required(),
  password: Joi.string().min(6).required(),
  firstName: Joi.string().max(50),
  lastName: Joi.string().max(50),
});

const loginSchema = Joi.object({
  email: Joi.string().email().required(),
  password: Joi.string().required(),
});

// Register
router.post('/register', async (req, res) => {
  try {
    const { error, value } = registerSchema.validate(req.body);
    if (error) {
      return res.status(400).json({ error: error.details[0].message });
    }

    const { username, email, password, firstName, lastName } = value;

    // Check if user exists
    const existingUser = await db.query(
      'SELECT id FROM users WHERE email = $1 OR username = $2',
      [email, username]
    );

    if (existingUser.rows.length > 0) {
      return res.status(409).json({ error: 'User already exists' });
    }

    // Hash password
    const passwordHash = await hashPassword(password);

    // Create user
    const result = await db.query(
      `INSERT INTO users (username, email, password_hash, first_name, last_name) 
       VALUES ($1, $2, $3, $4, $5) RETURNING id, username, email, first_name, last_name`,
      [username, email, passwordHash, firstName, lastName]
    );

    const user = result.rows[0];
    const token = generateToken({ id: user.id, email: user.email });

    res.status(201).json({
      message: 'User registered successfully',
      user: {
        id: user.id,
        username: user.username,
        email: user.email,
        firstName: user.first_name,
        lastName: user.last_name,
      },
      token,
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Login
router.post('/login', async (req, res) => {
  try {
    const { error, value } = loginSchema.validate(req.body);
    if (error) {
      return res.status(400).json({ error: error.details[0].message });
    }

    const { email, password } = value;

    // Find user
    const result = await db.query(
      'SELECT id, username, email, password_hash, first_name, last_name FROM users WHERE email = $1',
      [email]
    );

    if (result.rows.length === 0) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const user = result.rows[0];
    const isValidPassword = await comparePassword(password, user.password_hash);

    if (!isValidPassword) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const token = generateToken({ id: user.id, email: user.email });

    res.json({
      message: 'Login successful',
      user: {
        id: user.id,
        username: user.username,
        email: user.email,
        firstName: user.first_name,
        lastName: user.last_name,
      },
      token,
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

module.exports = router;</code></pre>
            </section>

            <!-- API Routes -->
            <section class="tutorial-section">
                <h2>Step 5: API Routes</h2>
                <p>Now let's create our main API routes for users and posts:</p>
                
                <h3>User Routes</h3>
                <pre><code class="language-javascript">// routes/users.js
const express = require('express');
const Joi = require('joi');
const db = require('../config/database');
const { authenticateToken } = require('../middleware/auth');

const router = express.Router();

// Validation schemas
const updateProfileSchema = Joi.object({
  firstName: Joi.string().max(50),
  lastName: Joi.string().max(50),
});

// Get current user profile
router.get('/profile', authenticateToken, async (req, res) => {
  try {
    const result = await db.query(
      'SELECT id, username, email, first_name, last_name, created_at FROM users WHERE id = $1',
      [req.user.id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }

    const user = result.rows[0];
    res.json({
      id: user.id,
      username: user.username,
      email: user.email,
      firstName: user.first_name,
      lastName: user.last_name,
      createdAt: user.created_at,
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Update user profile
router.put('/profile', authenticateToken, async (req, res) => {
  try {
    const { error, value } = updateProfileSchema.validate(req.body);
    if (error) {
      return res.status(400).json({ error: error.details[0].message });
    }

    const { firstName, lastName } = value;
    const updates = [];
    const values = [];
    let paramCount = 1;

    if (firstName !== undefined) {
      updates.push(`first_name = $${paramCount++}`);
      values.push(firstName);
    }
    if (lastName !== undefined) {
      updates.push(`last_name = $${paramCount++}`);
      values.push(lastName);
    }

    if (updates.length === 0) {
      return res.status(400).json({ error: 'No fields to update' });
    }

    updates.push(`updated_at = CURRENT_TIMESTAMP`);
    values.push(req.user.id);

    const result = await db.query(
      `UPDATE users SET ${updates.join(', ')} WHERE id = $${paramCount} RETURNING id, username, email, first_name, last_name`,
      values
    );

    const user = result.rows[0];
    res.json({
      message: 'Profile updated successfully',
      user: {
        id: user.id,
        username: user.username,
        email: user.email,
        firstName: user.first_name,
        lastName: user.last_name,
      },
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

module.exports = router;</code></pre>

                <h3>Post Routes</h3>
                <pre><code class="language-javascript">// routes/posts.js
const express = require('express');
const Joi = require('joi');
const db = require('../config/database');
const { authenticateToken } = require('../middleware/auth');

const router = express.Router();

// Validation schemas
const createPostSchema = Joi.object({
  title: Joi.string().min(1).max(255).required(),
  content: Joi.string().min(1).required(),
  published: Joi.boolean().default(false),
});

const updatePostSchema = Joi.object({
  title: Joi.string().min(1).max(255),
  content: Joi.string().min(1),
  published: Joi.boolean(),
});

// Get all posts (public)
router.get('/', async (req, res) => {
  try {
    const { page = 1, limit = 10, published = true } = req.query;
    const offset = (page - 1) * limit;

    const result = await db.query(
      `SELECT p.id, p.title, p.content, p.published, p.created_at, p.updated_at,
              u.username, u.first_name, u.last_name
       FROM posts p
       JOIN users u ON p.author_id = u.id
       WHERE p.published = $1
       ORDER BY p.created_at DESC
       LIMIT $2 OFFSET $3`,
      [published, limit, offset]
    );

    const countResult = await db.query(
      'SELECT COUNT(*) FROM posts WHERE published = $1',
      [published]
    );

    res.json({
      posts: result.rows,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: parseInt(countResult.rows[0].count),
        pages: Math.ceil(countResult.rows[0].count / limit),
      },
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get single post
router.get('/:id', async (req, res) => {
  try {
    const { id } = req.params;

    const result = await db.query(
      `SELECT p.id, p.title, p.content, p.published, p.created_at, p.updated_at,
              u.username, u.first_name, u.last_name
       FROM posts p
       JOIN users u ON p.author_id = u.id
       WHERE p.id = $1 AND p.published = true`,
      [id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Post not found' });
    }

    res.json(result.rows[0]);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Create post (authenticated)
router.post('/', authenticateToken, async (req, res) => {
  try {
    const { error, value } = createPostSchema.validate(req.body);
    if (error) {
      return res.status(400).json({ error: error.details[0].message });
    }

    const { title, content, published } = value;

    const result = await db.query(
      `INSERT INTO posts (title, content, author_id, published) 
       VALUES ($1, $2, $3, $4) RETURNING id, title, content, published, created_at`,
      [title, content, req.user.id, published]
    );

    const post = result.rows[0];
    res.status(201).json({
      message: 'Post created successfully',
      post,
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Update post (authenticated, author only)
router.put('/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { error, value } = updatePostSchema.validate(req.body);
    if (error) {
      return res.status(400).json({ error: error.details[0].message });
    }

    // Check if user is the author
    const postCheck = await db.query(
      'SELECT author_id FROM posts WHERE id = $1',
      [id]
    );

    if (postCheck.rows.length === 0) {
      return res.status(404).json({ error: 'Post not found' });
    }

    if (postCheck.rows[0].author_id !== req.user.id) {
      return res.status(403).json({ error: 'Not authorized to update this post' });
    }

    const { title, content, published } = value;
    const updates = [];
    const values = [];
    let paramCount = 1;

    if (title !== undefined) {
      updates.push(`title = $${paramCount++}`);
      values.push(title);
    }
    if (content !== undefined) {
      updates.push(`content = $${paramCount++}`);
      values.push(content);
    }
    if (published !== undefined) {
      updates.push(`published = $${paramCount++}`);
      values.push(published);
    }

    if (updates.length === 0) {
      return res.status(400).json({ error: 'No fields to update' });
    }

    updates.push(`updated_at = CURRENT_TIMESTAMP`);
    values.push(id);

    const result = await db.query(
      `UPDATE posts SET ${updates.join(', ')} WHERE id = $${paramCount} RETURNING id, title, content, published, created_at, updated_at`,
      values
    );

    const post = result.rows[0];
    res.json({
      message: 'Post updated successfully',
      post,
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Delete post (authenticated, author only)
router.delete('/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;

    // Check if user is the author
    const postCheck = await db.query(
      'SELECT author_id FROM posts WHERE id = $1',
      [id]
    );

    if (postCheck.rows.length === 0) {
      return res.status(404).json({ error: 'Post not found' });
    }

    if (postCheck.rows[0].author_id !== req.user.id) {
      return res.status(403).json({ error: 'Not authorized to delete this post' });
    }

    await db.query('DELETE FROM posts WHERE id = $1', [id]);

    res.json({ message: 'Post deleted successfully' });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

module.exports = router;</code></pre>
            </section>

            <!-- Testing -->
            <section class="tutorial-section">
                <h2>Step 6: Testing</h2>
                <p>Let's add comprehensive tests for our API endpoints:</p>
                
                <h3>Test Configuration</h3>
                <pre><code class="language-javascript">// jest.config.js
module.exports = {
  testEnvironment: 'node',
  setupFilesAfterEnv: ['<rootDir>/tests/setup.js'],
  testMatch: ['<rootDir>/tests/**/*.test.js'],
};</code></pre>

                <h3>Test Setup</h3>
                <pre><code class="language-javascript">// tests/setup.js
const request = require('supertest');
const app = require('../server');

global.request = request(app);</code></pre>

                <h3>Authentication Tests</h3>
                <pre><code class="language-javascript">// tests/auth.test.js
describe('Authentication', () => {
  describe('POST /api/auth/register', () => {
    it('should register a new user', async () => {
      const userData = {
        username: 'testuser',
        email: 'test@example.com',
        password: 'password123',
        firstName: 'Test',
        lastName: 'User',
      };

      const response = await request
        .post('/api/auth/register')
        .send(userData)
        .expect(201);

      expect(response.body).toHaveProperty('token');
      expect(response.body.user).toHaveProperty('email', userData.email);
      expect(response.body.user).not.toHaveProperty('password_hash');
    });

    it('should return 400 for invalid data', async () => {
      const invalidData = {
        username: 'te', // too short
        email: 'invalid-email',
        password: '123', // too short
      };

      await request
        .post('/api/auth/register')
        .send(invalidData)
        .expect(400);
    });

    it('should return 409 for existing user', async () => {
      const userData = {
        username: 'testuser',
        email: 'test@example.com',
        password: 'password123',
      };

      // First registration
      await request.post('/api/auth/register').send(userData).expect(201);

      // Second registration with same email
      await request.post('/api/auth/register').send(userData).expect(409);
    });
  });

  describe('POST /api/auth/login', () => {
    beforeEach(async () => {
      // Create a test user
      await request.post('/api/auth/register').send({
        username: 'logintest',
        email: 'login@example.com',
        password: 'password123',
      });
    });

    it('should login with valid credentials', async () => {
      const response = await request
        .post('/api/auth/login')
        .send({
          email: 'login@example.com',
          password: 'password123',
        })
        .expect(200);

      expect(response.body).toHaveProperty('token');
      expect(response.body.user).toHaveProperty('email', 'login@example.com');
    });

    it('should return 401 for invalid credentials', async () => {
      await request
        .post('/api/auth/login')
        .send({
          email: 'login@example.com',
          password: 'wrongpassword',
        })
        .expect(401);
    });
  });
});</code></pre>
            </section>

            <!-- Best Practices -->
            <section class="tutorial-section">
                <h2>Step 7: Best Practices & Production Considerations</h2>
                
                <h3>Security Best Practices</h3>
                <ul>
                    <li><strong>Input Validation:</strong> Always validate user input using Joi or similar</li>
                    <li><strong>SQL Injection Prevention:</strong> Use parameterized queries (we did this with pg)</li>
                    <li><strong>Password Security:</strong> Use bcrypt with high salt rounds (12+)</li>
                    <li><strong>JWT Security:</strong> Use strong secrets and reasonable expiration times</li>
                    <li><strong>Rate Limiting:</strong> Implement rate limiting to prevent abuse</li>
                    <li><strong>HTTPS:</strong> Always use HTTPS in production</li>
                </ul>

                <h3>Performance Optimization</h3>
                <ul>
                    <li><strong>Database Indexing:</strong> Add indexes for frequently queried columns</li>
                    <li><strong>Connection Pooling:</strong> Use connection pooling for database connections</li>
                    <li><strong>Caching:</strong> Implement Redis or similar for frequently accessed data</li>
                    <li><strong>Pagination:</strong> Always paginate list endpoints</li>
                    <li><strong>Compression:</strong> Enable gzip compression for responses</li>
                </ul>

                <h3>Error Handling</h3>
                <ul>
                    <li><strong>Consistent Error Format:</strong> Use consistent error response format</li>
                    <li><strong>Logging:</strong> Implement proper logging for debugging</li>
                    <li><strong>Graceful Degradation:</strong> Handle external service failures gracefully</li>
                    <li><strong>Validation Errors:</strong> Provide clear validation error messages</li>
                </ul>

                <h3>Production Deployment</h3>
                <ul>
                    <li><strong>Environment Variables:</strong> Never commit secrets to version control</li>
                    <li><strong>Health Checks:</strong> Implement health check endpoints</li>
                    <li><strong>Monitoring:</strong> Add application performance monitoring</li>
                    <li><strong>Documentation:</strong> Use OpenAPI/Swagger for API documentation</li>
                    <li><strong>CI/CD:</strong> Set up automated testing and deployment</li>
                </ul>
            </section>

            <!-- Next Steps -->
            <section class="tutorial-section">
                <h2>Next Steps</h2>
                <p>Congratulations! You've built a complete RESTful API with authentication. Here are some ways to extend it:</p>
                
                <ul>
                    <li><strong>File Uploads:</strong> Add file upload functionality for user avatars or post images</li>
                    <li><strong>Email Verification:</strong> Implement email verification for new registrations</li>
                    <li><strong>Role-Based Access:</strong> Add admin roles and permissions</li>
                    <li><strong>Search Functionality:</strong> Implement full-text search for posts</li>
                    <li><strong>Real-time Features:</strong> Add WebSocket support for real-time notifications</li>
                    <li><strong>API Documentation:</strong> Generate OpenAPI documentation automatically</li>
                </ul>
            </section>
        </div>

        <!-- Navigation -->
        <div class="tutorial-navigation">
            <a href="../tutorials.html" class="back-link">
                <i class="fas fa-arrow-left"></i>
                Back to Tutorials
            </a>
            <a href="react-performance-optimization.html" class="next-link">
                Next Tutorial: React Performance Optimization
                <i class="fas fa-arrow-right"></i>
            </a>
        </div>
    </main>

    <!-- Footer -->
    <footer class="footer">
        <div class="footer-content">
            <p>&copy; 2025 Klaus Mutwiri. All rights reserved.</p>
            <div class="footer-links">
                <a href="../privacy.html">Privacy Policy</a>
                <a href="../terms.html">Terms of Service</a>
                <a href="../disclaimer.html">Disclaimer</a>
            </div>
        </div>
    </footer>
</body>
</html>
